* MatrixClientProtocol.jl

The is the README for the [[https://github.com/non-Jedi/MatrixClientProtocol.jl][MatrixClientProtocol.jl]] implementation of a client for
[[https://matrix.org/docs/spec/client_server/r0.3.0.html][version r0.3.0 of the matrix.org Client-Server API]]. As a [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate program]], this
document is also the canonical source code for MatrixClientProtocol.jl.

All text in this document, the source code generated from this document, and all
other associated files are under copyright of [[Authors][the authors of
MatrixClientProtocol.jl]] unless otherwise noted. The aforementioned items are
available for your use subject to [[https://github.com/non-Jedi/MatrixClientProtocol.jl/blob/master/LICENSE.md][the GNU Public License, Version 3.0+]]. Within
this document, sections are quoted from the Client-Server API spec for matrix
and from [[https://github.com/matrix-org/matrix-doc/tree/client-server/r0.3.0/api][the swagger-compatible representation of the matrix APIs]]. All such
quotes will be called out with a footnote or some other attribution, and usage
of those quotes must follow the terms of [[https://github.com/matrix-org/matrix-doc/blob/client-server/r0.3.0/LICENSE][the license for the matrix.org
specification]].

** Contributing

At this time this project follows a workflow for non-core contributors as
follows:

1. Fork [[https://github.com/non-Jedi/MatrixClientProtocol.jl][the repository for this software on github]].
2. Checkout a new branch of the repository locally.
3. Make changes to README.org on your branch.
4. Add your name to [[Authors]].
5. Commit changes, trying your best to follow best practices for commit scoping
   and commit message formatting.
6. Push your branch back to a branch on your github fork of the project.
7. Issue a pull request from your branch to the master branch of the root
   repository.
8. I will review your pull request, merge it, generate the new "tangled" source
   code from README.org, and push a new commit to master.

If you are experienced with org-mode, you may include a commit generating new
source code in your pull request. A description of how to do so is available in
the org-mode documentation.

By issuing a pull request to this repository, you agree to release your
contribution under [[https://github.com/non-Jedi/MatrixClientProtocol.jl/blob/master/LICENSE.md][the terms of this project's license]].

** Authors
- [[https://matrix.to/#/@adam:thebeckmeyers.xyz][Adam Beckmeyer]]

** The Program

MatrixClientProtocol.jl is intended as a library to allow developers to easily
write applications making use of the matrix network or otherwise integrate the
matrix network into their Julia application. The initial scope of development
will be as follows, but more functionality may be added over time as needed or
implemented by other contributors:

- login/logout of matrix account
- join/leave matrix rooms
- send basic text messages into matrix rooms

This package makes some architectural decisions that may differ from normal
expectations (in addition to its nature as a literate program of course).
Although the Julia package ecosystem does not currently have [[https://sans-io.readthedocs.io/][a sans-io]]
implementation of HTTP, such a model is the preference of the library author, so
string representations of request/response bodies and query parameters will be
made available whenever practical. Rather than representing the many JSON forms
of matrix as hash maps, this library defines a native Julia struct to
deserialize/serialize JSON to/from. These structs will be generated from the
swagger-compatible representation of the API.

*** Swagger processing

Rather than digging into the vagaries of the specification for the swagger
specification, we choose the pragmatic approach of looking at the swagger files
for matrix and figuring out a "good enough" interpretation of them. If some day
in the future, a swagger/OpenAPI package exists for Julia, we will switch this
over to using that, but for now, writing such a package is bit farther than I'd
like to yak-shave today.

I've downloaded the matrix swagger[fn:1] in JSON form from
https://matrix.org/docs/api/client-server/json/api-docs.json and saved them as
~swagger.json~. At the top level, this file has the following structure:

#+BEGIN_SRC javascript
  {
      "host": "matrix.org:8448",
      "swagger": "2.0",
      "basePath": "/",
      "paths": {"...": "..."},
      "info": {
          "title": "Matrix Client-Server API",
          "version": "r0.3.0"
      },
      "schemes": ["https"],
      "produces": ["application/json"],
      "consumes": ["application/json"],
      "securityDefinitions": {
          "accessToken": {
              "description": "The access_token returned by a call to ``/login`` or ``/register``",
              "in": "query",
              "name": "access_token",
              "type": "apiKey"
          }
      }
  }
#+END_SRC

It seems clear from the above that the ~"paths"~ key has the information we're
interested in. Below is an extract from ~"paths"~ with just the information for
the "login" endpoint.

#+BEGIN_SRC javascript
  {
      "paths": {
          "/_matrix/client/r0/login": {
              "post": {
                  "description": "Authenticates the user, and issues an access token they can\nuse to authorize themself in subsequent requests.\n\nIf the client does not supply a ``device_id``, the server must\nauto-generate one.\n\nThe returned access token must be associated with the ``device_id``\nsupplied by the client or generated by the server. The server may\ninvalidate any access token previously associated with that device. See\n`Relationship between access tokens and devices`_.", 
                  "operationId": "login", 
                  "parameters": [
                      {
                          "in": "body", 
                          "name": "body", 
                          "schema": {
                              "example": {
                                  "initial_device_display_name": "Jungle Phone", 
                                  "password": "ilovebananas", 
                                  "type": "m.login.password", 
                                  "user": "cheeky_monkey"
                              }, 
                              "properties": {
                                  "address": {
                                      "description": "Third party identifier for the user.", 
                                      "type": "string"
                                  }, 
                                  "device_id": {
                                      "description": "ID of the client device. If this does not correspond to a\nknown client device, a new device will be created. The server\nwill auto-generate a device_id if this is not specified.", 
                                      "type": "string"
                                  }, 
                                  "initial_device_display_name": {
                                      "description": "A display name to assign to the newly-created device. Ignored\nif ``device_id`` corresponds to a known device.", 
                                      "type": "string"
                                  }, 
                                  "medium": {
                                      "description": "When logging in using a third party identifier, the medium of the identifier. Must be 'email'.", 
                                      "type": "string"
                                  }, 
                                  "password": {
                                      "description": "Required when ``type`` is ``m.login.password``. The user's\npassword.", 
                                      "type": "string"
                                  }, 
                                  "token": {
                                      "description": "Required when ``type`` is ``m.login.token``. The login token.", 
                                      "type": "string"
                                  }, 
                                  "type": {
                                      "description": "The login type being used.", 
                                      "enum": [
                                          "m.login.password", 
                                          "m.login.token"
                                      ], 
                                      "type": "string"
                                  }, 
                                  "user": {
                                      "description": "The fully qualified user ID or just local part of the user ID, to log in.", 
                                      "type": "string"
                                  }
                              }, 
                              "required": [
                                  "type"
                              ], 
                              "type": "object"
                          }
                      }
                  ], 
                  "responses": {
                      "200": {
                          "description": "The user has been authenticated.", 
                          "examples": {
                              "application/json": {
                                  "access_token": "abc123", 
                                  "device_id": "GHTYAJCE", 
                                  "home_server": "matrix.org", 
                                  "user_id": "@cheeky_monkey:matrix.org"
                              }
                          }, 
                          "schema": {
                              "properties": {
                                  "access_token": {
                                      "description": "An access token for the account.\nThis access token can then be used to authorize other requests.", 
                                      "type": "string"
                                  }, 
                                  "device_id": {
                                      "description": "ID of the logged-in device. Will be the same as the\ncorresponding parameter in the request, if one was specified.", 
                                      "type": "string"
                                  }, 
                                  "home_server": {
                                      "description": "The hostname of the homeserver on which the account has been registered.", 
                                      "type": "string"
                                  }, 
                                  "user_id": {
                                      "description": "The fully-qualified Matrix ID that has been registered.", 
                                      "type": "string"
                                  }
                              }, 
                              "type": "object"
                          }
                      }, 
                      "400": {
                          "description": "Part of the request was invalid. For example, the login type may not be recognised.", 
                          "examples": {
                              "application/json": {
                                  "errcode": "M_UNKNOWN", 
                                  "error": "Bad login type."
                              }
                          }
                      }, 
                      "403": {
                          "description": "The login attempt failed. For example, the password may have been incorrect.", 
                          "examples": {
                              "application/json": {
                                  "errcode": "M_FORBIDDEN"
                              }
                          }
                      }, 
                      "429": {
                          "description": "This request was rate-limited.", 
                          "schema": {
                              "description": "A Matrix-level Error", 
                              "properties": {
                                  "errcode": {
                                      "description": "An error code.", 
                                      "type": "string"
                                  }, 
                                  "error": {
                                      "description": "A human-readable error message.", 
                                      "type": "string"
                                  }
                              }, 
                              "required": [
                                  "errcode"
                              ], 
                              "type": "object"
                          }
                      }
                  }, 
                  "summary": "Authenticates the user.", 
                  "tags": [
                      "Session management"
                  ]
              }
          }
      }
  }
#+END_SRC

What we ultimately want here is a macro that takes as input a specific path,
looks at ~swagger.json~, and creates a set of structs that can be used to
encapsulate all required values for requesting the endpoint and for processing
the response.

We know the following about requests:

- tokens :: may be attached to any request as a query parameter or in a
            ~Authorization~ header as ~Bearer $access_token~ (not part of
            r0.3.0, but we'll include it anyway).
- Content-type :: for all requests will be ~application/json~
- ...

For this library, we will choose to pass access tokens in the header. So before
a request can be made to any endpoint, the following must be provided:

- ~Vector~ of ~Pair~ of query parameters
- ~Vector~ of ~Pair~ of headers
- Body content encoded as a JSON ~String~.

**** Process swagger schema object

Using the format seen above, the schema tells about what will happen in the
body. The first thing to create in evaluating this macro is a macro for
generating a struct representing the body. As a simple first pass, this macro
will be recursive.

Before we can write this macro, we'll need some utility functions. The first
turns the path from the swagger of the form ~"/_matrix/client/r0/login/"~ into
an UpperCamelCase type name e.g. ~:Login~. This function will return a symbol
since it will be used as the type's name in the macro. We need this so we can
call the struct for representing the body of a request to the aforementioned
endpoint something like ~:LoginRequestBody~.

#+NAME: function-typename
#+BEGIN_SRC jupyter-julia
  """
      typename(path::AbstractString)::Symbol

  Returns a name for e.g. "/_matrix/client/r0/my/fun/path" like "MyFunPath".
  """
  function typename(path::AbstractString)::Symbol
      splitpath = split(path, "/"; keep=false)
      Symbol(join(titlecase.(splitpath[4:end]), ""))
  end
#+END_SRC

Then we write a nice simple testcase for this function to make sure all is
working right.

#+NAME: function-typename-test
#+BEGIN_SRC jupyter-julia
  @test MatrixSwagger.typename("/_matrix/client/r0/my/fun/path") == :MyFunPath
#+END_SRC

Now we need a function that will insert a new field into a type expression.
Basically given an expression like ~:(struct Foo end)~, we want to be able to
call a function to create ~struct Foo; a::A end~ if given ~a~ and ~A~.

#+NAME: function-insertfield
#+BEGIN_SRC jupyter-julia
  # Need convenience function to turn types into symbols/expressions for `insertfield!`
  "Inserts field `a` of type `T` into a type expression."
  function insertfield!(ex::Expr, a::Symbol, T::Union{Symbol,Expr})
      if ex.head == :type
          push!(ex.args[end].args, :($a::$T))
      else
          throw(ArgumentError("Can only add field to concrete type expression"))
      end#if
  end#function
#+END_SRC

We should test that a struct has the fieldnames we'd expect after modifying its
expression with this function.

#+NAME: function-insertfield-test
#+BEGIN_SRC jupyter-julia
  @testset "insertfield!" begin
      e = :(struct Foo; a::String end)
      MatrixSwagger.insertfield!(e, :b, :Int64)
      @test all(e.args[end].args[end-1:end] .== [:(a::String), :(b::Int64)])
      MatrixSwagger.insertfield!(e, :c, :(Vector{Int64}))
      @test all(e.args[end].args[end-2:end] .==
                [:(a::String), :(b::Int64), :(c::Vector{Int64})])
  end
#+END_SRC

To feed into this function, we need to be able to map from the types defined in
the JSON schema in the swagger to real concrete Julia types. Then we will have
all the information we need to parse the nested JSON objects into a set of
nested Julia types.

#+NAME: function-juliatype
#+BEGIN_SRC jupyter-julia
  """
      juliatype(topleveltype::String[, nestedtypes...])::Type

  Return corresponding Julia type for a swagger type string.

  Throws ArgumentError for unknown types.
  """
  function juliatype(s::AbstractString, args...)::Union{Symbol,Expr}
      if s == "string"
          :String
      elseif s == "array" && !isempty(args)
          :(Vector{$(juliatype(args...))})
      elseif s == "object"
          :(Dict{String,Any})
      elseif s == "boolean"
          :Bool
      elseif s == "file"
          :IOBuffer
      elseif s == "integer"
          :Int64
      elseif s == "number"
          :Float64
      else
          throw(ArgumentError("No known corresponding Julia type"))
      end#if
  end#function
#+END_SRC

We should test that this handles both unnested and nested cases.

#+NAME: function-juliatype-test
#+BEGIN_SRC jupyter-julia
  @testset "juliatype" begin
      @test MatrixSwagger.juliatype("boolean") == :Bool
      @test MatrixSwagger.juliatype("array", "object") == :(Vector{Dict{String,Any}})
  end
#+END_SRC

#+NAME: macro-process-schema
#+BEGIN_SRC jupyter-julia
  macro process_schema(path::AbstractString, d::Dict)
      :(struct $path
        end)
  end

#+END_SRC

Now this should all be joined together in ~src~ and in ~test~.

#+BEGIN_SRC jupyter-julia :tangle src/MatrixSwagger.jl :noweb yes
  module MatrixSwagger

  <<function-typename>>

  <<function-insertfield>>

  <<function-juliatype>>

  end#module
#+END_SRC

#+BEGIN_SRC jupyter-julia :tangle test/MatrixSwagger.jl :noweb yes
  using MatrixClientProtocol: MatrixSwagger

  @testset "Utils" begin
      <<function-typename-test>>
      <<function-insertfield-test>>
      <<function-juliatype-test>>
  end
#+END_SRC

*** MatrixClientProtocol.jl

This file ties all of the previous work together, making modules available to
other modules, etc.

#+BEGIN_SRC jupyter-julia :tangle src/MatrixClientProtocol.jl
  module MatrixClientProtocol

  include("MatrixSwagger.jl")

  end#module
#+END_SRC

This file runs all the tests written in other files.

#+BEGIN_SRC jupyter-julia :tangle test/runtests.jl
  using Base.Test

  println("Starting tests...")

  @testset "Matrix Swagger" begin include("MatrixSwagger.jl") end
#+END_SRC
*** REQUIRE

This program is written using Julia v0.6 although v0.7 and stable v1.0 are on
the near horizon. In the absence of an [[https://github.com/python-hyper/hyper-h2][h2]]-style HTTP library for Julia, it uses
the HTTP.jl library for making requests to a matrix server and receiving
responses. JSON.jl is used for deserializing JSON from matrix server responses,
and for creating Julia structs from the swagger spec.

#+BEGIN_SRC jupyter-julia :tangle REQUIRE :eval never
  julia 0.6
  HTTP 0.4.3
  JSON 0.17.0
#+END_SRC

* Footnotes

[fn:1] https://github.com/matrix-org/matrix-doc/tree/client-server/r0.3.0/api
