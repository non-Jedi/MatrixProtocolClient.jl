* MatrixProtocolClient.jl

The is the README for the [[https://github.com/non-Jedi/MatrixProtocolClient.jl][MatrixProtocolClient.jl]] implementation of a client for
[[https://matrix.org/docs/spec/client_server/r0.3.0.html][version r0.3.0 of the matrix.org Client-Server API]]. As a [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate program]], this
document is also the canonical source code for MatrixProtocolClient.jl.

All text in this document, the source code generated from this document, and all
other associated files are under copyright of [[Authors][the authors of
MatrixProtocolClient.jl]] unless otherwise noted. The aforementioned items are
available for your use subject to [[https://github.com/non-Jedi/MatrixProtocolClient.jl/blob/master/LICENSE.md][the GNU Public License, Version 3.0+]]. Within
this document, sections are quoted from the Client-Server API spec for matrix
and from [[https://github.com/matrix-org/matrix-doc/tree/client-server/r0.3.0/api][the swagger-compatible representation of the matrix APIs]]. All such
quotes will be called out with a footnote or some other attribution, and usage
of those quotes must follow the terms of [[https://github.com/matrix-org/matrix-doc/blob/client-server/r0.3.0/LICENSE][the license for the matrix.org
specification]].

** Contributing

At this time this project follows a workflow for non-core contributors as
follows:

1. Fork [[https://github.com/non-Jedi/MatrixProtocolClient.jl][the repository for this software on github]].
2. Checkout a new branch of the repository locally.
3. Make changes to README.org on your branch.
4. Add your name to [[Authors]].
5. Commit changes, trying your best to follow best practices for commit scoping
   and commit message formatting.
6. Push your branch back to a branch on your github fork of the project.
7. Issue a pull request from your branch to the master branch of the root
   repository.
8. I will review your pull request, merge it, generate the new "tangled" source
   code from README.org, and push a new commit to master.

If you are experienced with org-mode, you may include a commit generating new
source code in your pull request. A description of how to do so is available in
the org-mode documentation.

By issuing a pull request to this repository, you agree to release your
contribution under [[https://github.com/non-Jedi/MatrixProtocolClient.jl/blob/master/LICENSE.md][the terms of this project's license]].

** Authors
- [[https://matrix.to/#/@adam:thebeckmeyers.xyz][Adam Beckmeyer]]

** The Program

MatrixProtocolClient.jl is intended as a library to allow developers to easily
write applications making use of the matrix network or otherwise integrate the
matrix network into their Julia application. The initial scope of development
will be as follows, but more functionality may be added over time as needed or
implemented by other contributors:

- login/logout of matrix account
- join/leave matrix rooms
- send basic text messages into matrix rooms

This package makes some architectural decisions that may differ from normal
expectations (in addition to its nature as a literate program of course).
Although the Julia package ecosystem does not currently have [[https://sans-io.readthedocs.io/][a sans-io]]
implementation of HTTP, such a model is the preference of the library author, so
string representations of request/response bodies and query parameters will be
made available whenever practical. Rather than representing the many JSON forms
of matrix as hash maps, this library defines a native Julia struct to
deserialize/serialize JSON to/from. These structs will be generated from the
swagger-compatible representation of the API.

*** HTTP Endpoints

Here we'll create types and functions to make access of the matrix HTTP apis
convenient. First, we should make it possible to login.

**** General setup

First of all, login endpoints along with many parts of matrix use "types" with
Java-style namespaces. For login, we have ~m.login.password~ for example. We'll
represent these with a simple parametric type with no fields where the parameter
will be a tuple of the form ~(:m, :login, :password)~. This will allow
specialization and dispatching on these types when they appear.

For convenience, we'll also define abstract types for grouping processed
requests and responses from the matrix server. In general, functions calling
matrix api endpoints should accept ~Endpoint~ type arguments and return
~Response~.

#+NAME: matrix-type
#+BEGIN_SRC julia
  abstract type Endpoint{M} end

  abstract type Response{E <: Endpoint} end
#+END_SRC

Even though we're only designing the system for logging in now, we can see that
we'll need to be able to send a wide variety of HTTP requests. So let's define a
basic fallback function for that purpose.

#+NAME: matrix-request
#+BEGIN_SRC julia
  import HTTP

  export request

  """
      request(::Endpoint; layers)::Tuple

  Calls a matrix endpoint and returns a tuple for input to `HTTP.request`

  `layers` is passed through to `HTTP.stack` as kwargs to specify which layers to
  include.
  """
  function request(req::Endpoint, body; layers...)::Tuple{
      DataType, String, HTTP.URI, HTTP.Headers, Any
  }
      (HTTP.stack(;layers...), method(req), url(req), headers(req), body)
  end#function
#+END_SRC

This begins to show us what methods need an implementation for all
~Endpoint~ types, defining the interface:

- ~method~
- ~url~ or both ~path~ and ~query~
- ~headers~ (defaults to only including the Authorization header)
- ~process_response~
- ~response_type~ which will be shown later

For the first, this is why we made ~Endpoint~ parametric. We define
~method~ as follows.

#+NAME: method
#+BEGIN_SRC julia
  function method(req::Endpoint{M})::AbstractString where {M}
      if M in (:GET, :HEAD, :POST, :PUT, :DELETE, :TRACE, :OPTIONS, :CONNECT, :PATCH)
          string(M)
      else
          throw(DomainError(M, "Not a valid HTTP method."))
      end#if
  end#function
#+END_SRC

For ~url~, we will assume that ~Endpoint~ has a ~host~ field. We also must
define ~path~ and ~query~ methods. Zero query params will be set as the default
case, but there is no sane default for ~path~.

#+NAME: url
#+BEGIN_SRC julia
  import HTTP.URIs: URI

  url(req::Endpoint)::URI =
      URI(; scheme="https", host=req.host, path=path(req), query=query(req))
  query(::Endpoint) = ""
#+END_SRC

Specific headers may be needed on each endpoint, but the most common header
needed by matrix is the ~Authorization~ header for transmitting the user's
access token. ~Endpoint~ types will have to opt out of having this token
sent in the headers.

#+NAME: headers
#+BEGIN_SRC julia
  headers(req::Endpoint) = defaultheaders(req)
  defaultheaders(req::Endpoint) = ["Authorization" => "Bearer " * token(req)]
  token(req::Endpoint) = req.token
#+END_SRC

The most complicated of these methods is ~process_response~. This will be
defined independently for each endpoint and method.

For utility we define the following constants and utility functions for using
them.

#+NAME: http-consts
#+begin_src julia
  const base_path = ["/_matrix", "client", "r0"]
  extend_path(extpath::AbstractVector{<:AbstractString}) =
      join(vcat(base_path, extpath), "/")
#+end_src

**** Login

First we define the types for ~GET~ and ~POST~ requests to the login endpoint.

#+NAME: login-request
#+begin_src julia
  struct GetLogin <: Endpoint{:GET}
      host::String
  end

  headers(::GetLogin) = HTTP.Headers()
  path(::GetLogin) = extend_path(["login"])
#+end_src

#+NAME: login-request-test
#+begin_src julia
  import MatrixProtocolClient: MatrixHTTP
  using HTTP

  @testset "get login" begin
      let MH = MatrixHTTP, ep = MH.GetLogin("example.com"), u = MH.url(ep)
          let reqtuple = MH.request(ep)
              @test MH.method(ep) == "GET"
              @test u.host == "example.com"
              @test u.path == "/_matrix/client/r0/login"
              @test u.scheme == "https"
              @test isempty(u.query)
              @test isempty(MH.headers(ep))
              @test reqtuple[1] === HTTP.stack()
              @test reqtuple[2] == "GET"
              @test reqtuple[3] == u
              @test isempty(reqtuple[4])
              @test isempty(reqtuple[5])
          end#let
      end#let
  end#testset

#+end_src

The more difficult bit is processing this response. For this we need
to define a struct with all the potential information from the
response.

#+NAME: login-request-process
#+begin_src julia
  struct GetLoginResponse{S <: AbstractString} <: Response{GetLogin}
	  flows::Vector{S}
  end#struct

  import LazyJSON
  const LJ = LazyJSON

  function process_response(endpoint::GetLogin, resp::HTTP.Response)
	  GetLoginResponse([i.type for i in LJ.value(String(resp.body)).flows])
  end#function
#+end_src

#+NAME: login-request-process-test
#+begin_src julia
  import MatrixProtocolClient: MatrixHTTP
  const MH = MatrixHTTP
  import HTTP: Response

  @testset "get login process" begin
	  let resp = Response(200; body=
		  Vector{UInt8}("{\"flows\": [{\"type\": \"m.login.password\"}]}")),
		  glr = MH.process_response(MH.GetLogin("example.com"), resp)
		  @test length(glr.flows) == 1
		  @test glr.flows[1] == "m.login.password"
	  end#let
  end#testset
#+end_src

Now that we've done so for a =GET= request to the login endpoint,
we'll also define things for the =POST= needed to actually
login. Before that, though, we need to define ~Identifier~ types as
specified in the matrix CS api.

#+NAME: identifier-types
#+begin_src julia
  import JSON

  abstract type Identifier end

  struct UserIdentifier <: Identifier
	  user::String
  end#struct

  identifier_type(::UserIdentifier) = "m.id.user"

  struct ThirdPartyIdentifier <: Identifier
	  medium::String
	  Address::String
  end#struct

  identifier_type(::ThirdPartyIdentifier) = "m.id.thirdparty"

  struct PhoneIdentifier <: Identifier
	  country::String
	  phone::String
  end#struct

  identifier_type(::PhoneIdentifier) = "m.id.phone"

  struct IdentifierWrapper{T<:Identifier}
	  wrapped::T
	  fns::Vector{Symbol}
  end

  IdentifierWrapper(x::Identifier, syms) = IdentifierWrapper(x, collect(syms))
  IdentifierWrapper(x::T) where {T <: Identifier} = IdentifierWrapper(x, fieldnames(T))

  JSON.lower(a::Identifier) = IdentifierWrapper(a)

  function JSON.show_json(io::JSON.StructuralContext, s::JSON.CommonSerialization,
						  x::IdentifierWrapper)
	  JSON.begin_object(io)
	  JSON.show_pair(io, s, "type", identifer_type(x.wrapped))
	  for fn in x.fns
		  JSON.show_pair(io, s, fn, getfield(x.wrapped, fn))
	  end#for
	  JSON.end_object(io)
  end#function
#+end_src

#+NAME: post-login
#+begin_src julia
  struct PostLogin <: Endpoint{:POST}
      host::String
  end

  "Return body for `POST` login request"
  function (ep::PostLogin)(logintype::String; identifier=nothing, password=nothing,
                           token=nothing, device_id=nothing,
                           initial_device_display_name=nothing)
      # First check for valid input
      logintype in ("m.login.password", "m.login.token") || throw(DomainError(logintype))
      if logintype == "m.login.password" && isnothing(password)
          throw(DomainError(password,
                            "Password must be provided for \"m.login.password\""))
      end#if
      if logintype == "m.login.token" && isnothing(token)
          throw(DomainError(token,
                            "Token must be provided for \"m.login.token\""))
      end#if
  end#function

  headers(::PostLogin) = HTTP.Headers()
  path(::PostLogin) = extend_path(["login"])
#+end_src

**** MatrixHTTP.jl

#+BEGIN_SRC julia :tangle src/MatrixHTTP.jl :noweb yes :comments noweb
  module MatrixHTTP

  <<matrix-type>>
  <<identifier-types>>
  <<matrix-request>>
  <<method>>
  <<url>>
  <<headers>>
  <<body>>
  <<http-consts>>
  <<login-request>>
  <<login-request-process>>
  <<post-login>>

  end#module
#+END_SRC

#+BEGIN_SRC julia :tangle test/MatrixHTTP.jl :noweb yes :comments noweb
  using Test

  <<login-request-test>>
  <<login-request-process-test>>
#+END_SRC


*** MatrixProtocolClient.jl

This file ties all of the previous work together, making modules available to
other modules, etc.

#+BEGIN_SRC julia :tangle src/MatrixProtocolClient.jl :comments noweb
  module MatrixProtocolClient

  include("MatrixHTTP.jl")

  end#module
#+END_SRC

This file runs all the tests written in other files.

#+BEGIN_SRC julia :tangle test/runtests.jl :comments noweb
  include("MatrixHTTP.jl")
#+END_SRC
